%!PS

% Implementation of brainfuck interpreter in PostScript

% Return jump stack implemented with an array with the top at the start.
% filepos stack-arr push-jump stack-arr'
/push-jump { aload length 1 add array astore } bind def
% stack-arr pop-jump stack-arr'
/pop-jump { dup 1 exch length 1 sub getinterval } bind def
% stack-arr top-jump filepos
/top-jump { 0 get } bind def

% file next-cmd int
/next-cmd { read not { exit } if } bind def

% - get-char int
/get-char {
  {
    (%lineedit) (r) file
    dup read {
      exch
      dup flushfile closefile
      exit
    } if
    pop
  } loop
} bind def

% Commands array - initialise as no-bf-ops and then add specific commands

% - no-op -
/no-op { } bind def
/bf-ops [ 256 { //no-op } repeat ] def

bf-ops
dup (>) 0 get { /bf-data bf-data 1 add def } bind put
dup (<) 0 get { /bf-data bf-data 1 sub def } bind put
dup (+) 0 get { bf-cells bf-data 2 copy get 1 add put } bind put
dup (-) 0 get { bf-cells bf-data 2 copy get 1 sub put } bind put
dup (.) 0 get { bf-stdout dup bf-cells bf-data get write flushfile } bind put
dup (,) 0 get { bf-cells bf-data get-char put } bind put
dup ([) 0 get {
  bf-cells bf-data get 0 ne {
    /bf-jumps bf-source fileposition bf-jumps push-jump def
  }{
    % Jump to matching ]. Count +1 for [ and -1 for ]. If the count is 0 for a
    % ] it is the matching ] command.
    0 {
      bf-source next-cmd
      dup ([) 0 get eq {
        pop 1 add
      }{
        (]) 0 get eq {
          dup 0 eq {
            pop exit
          } if
          1 sub
        } if
      } ifelse
    } loop
  } ifelse
} bind put
dup (]) 0 get {
  bf-cells bf-data get 0 ne {
    bf-source bf-jumps top-jump setfileposition
  }{
    /bf-jumps bf-jumps pop-jump def
  } ifelse
} bind put
pop

% file bf-init state-dict
/bf-init {
  <<
    % Command bf-source file
    /bf-source 3 -1 roll
    % Output defaults to stdout
    /bf-stdout (%stdout) (w) file
    % Use array of integer objects for the bf-cells instead of string
    /bf-cells 65535 string
    /bf-data 0
    % Array based stack of jump back file positions
    /bf-jumps 0 array
  >>
} bind def

% state-dict bf-interp -
/bf-interp {
  begin
    { bf-ops bf-source next-cmd get exec } loop
  end
} bind def

% file bf -
/bf {
  bf-init
  bf-interp
} bind def

currentfile bf
+++++ +++++             initialize counter (cell #0) to 10
[                       use loop to set the next four cells to 70/100/30/10
    > +++++ ++              add  7 to cell #1
    > +++++ +++++           add 10 to cell #2
    > +++                   add  3 to cell #3
    > +                     add  1 to cell #4
    <<<< -                  decrement counter (cell #0)
]
> ++ .                  print 'H'
> + .                   print 'e'
+++++ ++ .              print 'l'
.                       print 'l'
+++ .                   print 'o'
> ++ .                  print ' '
<< +++++ +++++ +++++ .  print 'W'
> .                     print 'o'
+++ .                   print 'r'
----- - .               print 'l'
----- --- .             print 'd'
> + .                   print '!'
> .                     print '\n'
> , + .
< .
